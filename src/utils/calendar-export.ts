import type { CourseData } from "@/types";

export interface CalendarExportOptions {
  includeLabs: boolean;
  includeExams: boolean;
  reminderMinutes: number | null;
  titleFormat: "code" | "name" | "both";
  includeSection: boolean;
  includeFaculty: boolean;
  customStartDate?: string;
  customEndDate?: string;
}

export const defaultExportOptions: CalendarExportOptions = {
  includeLabs: true,
  includeExams: true,
  reminderMinutes: 15,
  titleFormat: "both",
  includeSection: true,
  includeFaculty: true,
};

const dayToICalDay: Record<string, string> = {
  SUNDAY: "SU",
  MONDAY: "MO",
  TUESDAY: "TU",
  WEDNESDAY: "WE",
  THURSDAY: "TH",
  FRIDAY: "FR",
  SATURDAY: "SA",
};

const dayToNumber: Record<string, number> = {
  SUNDAY: 0,
  MONDAY: 1,
  TUESDAY: 2,
  WEDNESDAY: 3,
  THURSDAY: 4,
  FRIDAY: 5,
  SATURDAY: 6,
};

function generateUID(): string {
  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}@routinebuzz.app`;
}

function formatICalDate(dateStr: string): string {
  return dateStr.replace(/-/g, "");
}

function formatICalTime(timeStr: string): string {
  const parts = timeStr.split(":");
  const hours = parts[0].padStart(2, "0");
  const minutes = (parts[1] || "00").padStart(2, "0");
  const seconds = (parts[2] || "00").padStart(2, "0");
  return `${hours}${minutes}${seconds}`;
}

function formatICalDateTime(dateStr: string, timeStr: string): string {
  return `${formatICalDate(dateStr)}T${formatICalTime(timeStr)}`;
}

function getICalTimestamp(): string {
  const now = new Date();
  return now.toISOString().replace(/[-:]/g, "").replace(/\.\d{3}/, "");
}

function escapeICalText(text: string): string {
  return text
    .replace(/\\/g, "\\\\")
    .replace(/;/g, "\\;")
    .replace(/,/g, "\\,")
    .replace(/\n/g, "\\n");
}

// RFC 5545: lines must not exceed 75 octets
function foldLine(line: string): string {
  const maxLength = 75;
  if (line.length <= maxLength) return line;

  const lines: string[] = [];
  let remaining = line;

  while (remaining.length > maxLength) {
    lines.push(remaining.substring(0, maxLength));
    remaining = " " + remaining.substring(maxLength);
  }
  lines.push(remaining);

  return lines.join("\r\n");
}

function findFirstOccurrence(startDate: string, dayName: string): Date {
  const date = new Date(startDate);
  const targetDay = dayToNumber[dayName.toUpperCase()];
  const currentDay = date.getDay();

  let daysToAdd = targetDay - currentDay;
  if (daysToAdd < 0) daysToAdd += 7;

  date.setDate(date.getDate() + daysToAdd);
  return date;
}

function dateToICalDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}${month}${day}`;
}

function generateEventTitle(
  course: CourseData,
  isLab: boolean,
  options: CalendarExportOptions,
): string {
  const courseName = course.labName
    ? course.labName.replace(/\s+LAB$/i, "").trim()
    : course.courseCode;

  let title = "";

  switch (options.titleFormat) {
    case "code":
      title = isLab ? `${course.courseCode}L` : course.courseCode;
      break;
    case "name":
      title = isLab ? `${courseName} Lab` : courseName;
      break;
    case "both":
    default:
      title = isLab
        ? `${course.courseCode}L - ${courseName} Lab`
        : `${course.courseCode} - ${courseName}`;
      break;
  }

  if (options.includeSection) {
    title += ` (Sec ${course.sectionName})`;
  }

  return title;
}

function generateEventDescription(
  course: CourseData,
  isLab: boolean,
  options: CalendarExportOptions,
): string {
  const parts: string[] = [];

  parts.push(`Course: ${course.courseCode}`);
  parts.push(`Section: ${course.sectionName}`);
  parts.push(`Credits: ${course.courseCredit}`);

  if (options.includeFaculty) {
    const faculty = isLab ? course.labFaculties : course.faculties;
    parts.push(`Faculty: ${faculty || "TBA"}`);
  }

  if (course.prerequisiteCourses && course.prerequisiteCourses !== "N/A") {
    parts.push(`Prerequisites: ${course.prerequisiteCourses}`);
  }

  parts.push("");
  parts.push("Generated by RoutineBuzz");

  return parts.join("\\n");
}

function generateAlarm(minutesBefore: number): string {
  return [
    "BEGIN:VALARM",
    "ACTION:DISPLAY",
    `DESCRIPTION:Class starting in ${minutesBefore} minutes`,
    `TRIGGER:-PT${minutesBefore}M`,
    "END:VALARM",
  ].join("\r\n");
}

function generateRecurringEvent(
  course: CourseData,
  schedule: { startTime: string; endTime: string; day: string },
  isLab: boolean,
  options: CalendarExportOptions,
  startDate: string,
  endDate: string,
): string {
  const uid = generateUID();
  const timestamp = getICalTimestamp();
  const firstOccurrence = findFirstOccurrence(startDate, schedule.day);
  const eventStartDate = dateToICalDate(firstOccurrence);
  const startTime = formatICalTime(schedule.startTime);
  const endTime = formatICalTime(schedule.endTime);
  const location = isLab ? course.labRoomName || "TBA" : course.roomName || "TBA";
  const title = generateEventTitle(course, isLab, options);
  const description = generateEventDescription(course, isLab, options);
  const iCalDay = dayToICalDay[schedule.day.toUpperCase()];

  const lines: string[] = [
    "BEGIN:VEVENT",
    `UID:${uid}`,
    `DTSTAMP:${timestamp}`,
    `DTSTART:${eventStartDate}T${startTime}`,
    `DTEND:${eventStartDate}T${endTime}`,
    `RRULE:FREQ=WEEKLY;BYDAY=${iCalDay};UNTIL=${formatICalDate(endDate)}T235959`,
    foldLine(`SUMMARY:${escapeICalText(title)}`),
    foldLine(`LOCATION:${escapeICalText(location)}`),
    foldLine(`DESCRIPTION:${description}`),
    `CATEGORIES:${isLab ? "LAB" : "CLASS"}`,
    `STATUS:CONFIRMED`,
  ];

  if (options.reminderMinutes !== null) {
    lines.push(generateAlarm(options.reminderMinutes));
  }

  lines.push("END:VEVENT");
  return lines.join("\r\n");
}

function generateExamEvent(
  course: CourseData,
  examType: "midterm" | "final",
  options: CalendarExportOptions,
): string | null {
  const uid = generateUID();
  const timestamp = getICalTimestamp();
  const isMidterm = examType === "midterm";

  const examDate = isMidterm
    ? course.sectionSchedule.midExamDate
    : course.sectionSchedule.finalExamDate;
  const examStartTime = isMidterm
    ? course.sectionSchedule.midExamStartTime
    : course.sectionSchedule.finalExamStartTime;
  const examEndTime = isMidterm
    ? course.sectionSchedule.midExamEndTime
    : course.sectionSchedule.finalExamEndTime;

  if (!examDate || examDate === "null") return null;

  const courseName = course.labName
    ? course.labName.replace(/\s+LAB$/i, "").trim()
    : course.courseCode;

  const examTypeLabel = isMidterm ? "Midterm" : "Final";
  let title = "";
  switch (options.titleFormat) {
    case "code":
      title = `${course.courseCode} ${examTypeLabel}`;
      break;
    case "name":
      title = `${courseName} ${examTypeLabel}`;
      break;
    case "both":
    default:
      title = `${course.courseCode} - ${courseName} ${examTypeLabel}`;
      break;
  }

  if (options.includeSection) {
    title += ` (Sec ${course.sectionName})`;
  }

  const description = [
    `${examTypeLabel} Exam`,
    `Course: ${course.courseCode}`,
    `Section: ${course.sectionName}`,
    options.includeFaculty ? `Faculty: ${course.faculties || "TBA"}` : "",
    "",
    "Generated by RoutineBuzz",
  ]
    .filter(Boolean)
    .join("\\n");

  const lines: string[] = [
    "BEGIN:VEVENT",
    `UID:${uid}`,
    `DTSTAMP:${timestamp}`,
    `DTSTART:${formatICalDateTime(examDate, examStartTime)}`,
    `DTEND:${formatICalDateTime(examDate, examEndTime)}`,
    foldLine(`SUMMARY:${escapeICalText(title)}`),
    foldLine(`DESCRIPTION:${description}`),
    `CATEGORIES:EXAM`,
    `STATUS:CONFIRMED`,
  ];

  if (options.reminderMinutes !== null) {
    lines.push(generateAlarm(60));
    lines.push(generateAlarm(1440));
  }

  lines.push("END:VEVENT");
  return lines.join("\r\n");
}

export function generateICalendar(
  courses: CourseData[],
  options: CalendarExportOptions = defaultExportOptions,
): string {
  const events: string[] = [];

  for (const course of courses) {
    const startDate = options.customStartDate || course.sectionSchedule.classStartDate;
    const endDate = options.customEndDate || course.sectionSchedule.classEndDate;

    if (course.sectionSchedule.classSchedules) {
      for (const schedule of course.sectionSchedule.classSchedules) {
        events.push(generateRecurringEvent(course, schedule, false, options, startDate, endDate));
      }
    }

    if (options.includeLabs && course.labSchedules) {
      for (const schedule of course.labSchedules) {
        events.push(generateRecurringEvent(course, schedule, true, options, startDate, endDate));
      }
    }

    if (options.includeExams) {
      const midtermEvent = generateExamEvent(course, "midterm", options);
      if (midtermEvent) events.push(midtermEvent);

      const finalEvent = generateExamEvent(course, "final", options);
      if (finalEvent) events.push(finalEvent);
    }
  }

  const calendarLines: string[] = [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//RoutineBuzz//Course Schedule//EN",
    "CALSCALE:GREGORIAN",
    "METHOD:PUBLISH",
    `X-WR-CALNAME:My Course Schedule`,
    `X-WR-CALDESC:Course schedule exported from RoutineBuzz`,
    ...events,
    "END:VCALENDAR",
  ];

  return calendarLines.join("\r\n");
}

export function downloadICalendar(
  courses: CourseData[],
  options: CalendarExportOptions = defaultExportOptions,
  filename: string = "routine",
): void {
  const icsContent = generateICalendar(courses, options);
  const blob = new Blob([icsContent], { type: "text/calendar;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = `${filename}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  URL.revokeObjectURL(url);
}
